/*
 * Проект: "Нелинейный фильтр ограничения скорости, ускорения и рывка"
 * Версия: 0.1a
 * Файл: "rfilt.c"
 */

//-----------------------------------------------------------------------------
#include <math.h>
#include "rfilt.h"
//-----------------------------------------------------------------------------
// инициализация фильтра
void rfilt_init(
  rfilt_t *self,     // указатель на внутреннюю структуру фильтра
  double dt,         // шаг вызова процедуры фильтрации по времени
  double v_max,      // максимальная скорость
  double a_up_max,   // максимальное ускорение разгона
  double a_down_max, // максимальное ускорение торможения
  double r_max,      // максимальный рывок
  double beta,       // коэффициент запаса фильтра [0..0.1)
  double x_init,     // начальное положение
  double x_min,      // ограничение снизу
  double x_max)      // ограничение сверху
{
  rfilt_tune(self, dt, v_max, a_up_max, a_down_max, r_max, beta, x_min, x_max);

  self->x = x_init;
  self->v = 0.;
  self->a = 0.;

  self->s  = 0.;
  self->nt = 0.;
}
//-----------------------------------------------------------------------------
// установка параметров фильтра "на лету"
void rfilt_tune(
  rfilt_t *self,     // указатель на внутреннюю структуру фильтра
  double dt,         // шаг вызова процедуры фильтрации по времени
  double v_max,      // максимальная скорость
  double a_up_max,   // максимальное ускорение разгона
  double a_down_max, // максимальное ускорение торможения
  double r_max,      // максимальный рывок
  double beta,       // коэффициент запаса фильтра [0..0.1)
  double x_min,      // ограничение снизу
  double x_max)      // ограничение сверху
{
  double dt2 = dt * dt;
  self->V    = v_max * dt;
  self->Au   = a_up_max   * dt2;
  self->Ad   = a_down_max * dt2;
  self->R    = r_max * dt2 * dt;
  self->B    = RFILT_LIMIT(beta, 0., 1.);
  self->Xmin = x_min;
  self->Xmax = x_max;
}
//-----------------------------------------------------------------------------
// ограничение рывка в связи с ограничением скорости и ускорения
static double rfilt_limit_r(
  rfilt_t *self, // указатель на внутреннюю структуру фильтра (константы)
  double v,      // приведенная текущая скорость
  double a,      // приведенное текущее ускорение
  double r)      // предлагаемый рывок
{
  double A, vc;

  if (v * a < 0.)
  { // торможение (скорость и ускорение не равны нулю и имеют разный знак
    A = self->Ad; // максимальное приведенное ускорение торможения
  }
  else // if (trend >= 0)
  { // разгон (знаки скорости и ускорения совпадают или нули)
    A = self->Au; // максимальное приведенное ускорение разгона
  }

#if 1 // ограничить рывок в связи с ограничением ускорения
  if (a + r >  A) r =  A - a;
  if (a + r < -A) r = -A - a;
  // возможна ситуация смены знака скорости при этом возникает
  // большой рывок с Ad на Au (или наоборот)
  //r = RFILT_LIMIT_ABS(r, self->R); // FIXME: !!!???
#endif

#if 1 // ограничить рывок в связи с ограничением скорости
  // вычислить критическую скорость, выше которой требуется
  // "быстрое" снижения ускорения разгона для предотвращения
  // превышения по модулю максимальной скорости self->V
  vc  = self->V - a  * a  / (2. * self->R);

  if ((a > 0. && v >=  vc) ||
      (a < 0. && v <= -vc))
  { // текущая скорость достигла критической
    r = RFILT_LIMIT_ABS(-a, self->R);
    //RFILT_DBG("critical V: v=%f a=%f r=%f vcrit=%f vapprox=%f",
    //          v, a, r, vc, v + a * a / (2. * self->R));
  }
  else if (a >= 0. && v > self->V)
  { // скорость превысила +Vmax
    a = 0.;
    if (r > 0.) r = 0.;
    //RFILT_DBG("v=%f > Vmax=%f r=%f", v, self->V, r);
  }
  else if (a <= 0. && v < -self->V)
  { // скорость ниже -Vmin
    a = 0.;
    if (r < 0.) r = 0.;
    //RFILT_DBG("v=%f < -Vmax=%f r=%f", v, -self->V, r);
  }
#endif

  return r;
}
//----------------------------------------------------------------------------
// расчёт тормозного пути
// (функция возвращает минимальный тормозной путь со знаком, а так же nt)
static double rfilt_s(
  rfilt_t *self, // указатель на внутреннюю структуру фильтра (константы)
  double R,      // максимальный приведенный рывок
  double v,      // приведенная текущая скорость
  double a,      // приведенное текущее ускорение
  double *nt)    // минимальное время торможения в тактах
{
  double s = 0., a2 = a * a, Ad2 = self->Ad * self->Ad;
  double dt, dt2;
  double sig = (v >= 0.) ? 1. : -1.;
  v *= sig; // теперь v >= 0
  a *= sig;

  if (a >= 0.)
  { // тормозной путь после разгона (a и v одного знака) или
    // после равномерного движения с постоянной скоростью v и ускорением a=0.

    // вычислить максимальную приведенную скорость (фактически по модулю)
    // достигаемую за время обнуления начального ускорения разгона
    // с максимальным рывком
    double vmax = v + a2 / (2. * R); // vmax >= 0

    dt  = a / R; // время обнуления текущего ускорения
    s   = dt * (v + a2 / (3. * R)); // тормозной путь обнуления ускорения
    *nt = dt;

    if (vmax <= self->Ad * self->Ad / R)
    { // торможение состоит из 2-х фаз
      dt   = sqrt(vmax / R); // время каждой фазы
      s   += dt * vmax; // тормозной путь ф1 и ф2
      *nt += dt * 2.;   // время торможения ф1 и ф2
    }
    else
    { // торможение состоит из 3-х фаз
      dt   = vmax / self->Ad + self->Ad / R; // время всех фаз
      s   += vmax * dt / 2.; // тормозной путь ф1..ф3
      *nt += dt;             // время торможения ф1..ф3
    }
  }
  else // if (a < 0.)
  { // тормозной путь после начала торможения

    // вычислить критические пороги по скорости
    double v1 = a2 / (R * 2.); // с меньшей скоростью торможение с выбегом
    double v2 = Ad2 / R - v1;

    if (v >= v2)
    { // торможение в 3 фазы c набором тормозного ускорения Ad

      // фаза 1 (увеличиваем тормозное ускорения с а до Ad)
      dt  = (self->Ad + a) / R; // помним, что a<0
      dt2 = dt * dt;
      s   = v * dt + a * dt2 / 2. - R * dt2 * dt / 6.;
      *nt = dt;

      // фаза 2 (тормозим с постоянным ускорением Ad)
      dt   = (v - v2) / self->Ad;
      s   += (v + a2 / (2. * R)) * dt * 0.5;
      *nt += dt;

      // фаза 3 (обнуляем скорость и ускорение с максимальным рывком)
      dt   = self->Ad / R;
      s   += R * dt * dt * dt / 6.;
      *nt += dt;
    }
    else if (v >= v1) // && v < v2
    { // торможение в 2 фазы c |amax|<Ad

      // максимальное по модулью ускорение в конце первой фазы
      double amax = sqrt(R * v + a2 * 0.5);

      // фаза 1 (увеличиваем тормозное ускорения с а до amax)
      dt = (amax + a) / R; // помним, что a<0
      dt2 = dt * dt;
      s   = v * dt + a * dt2 / 2. - R * dt2 * dt / 6.;
      *nt = dt;

      // фаза 2 (обнуляем скорость и ускорение с максимальным рывком)
      dt   = amax / R;
      s   += R * dt * dt * dt / 6.;
      *nt += dt;
    }
    else // if (v < v1)
    { // торможение с "выбегом" (3 или 4 фазы)

      // фаза 1 (сбрасываем ускорение до нуля)
      dt = -a / R; // помним, что a<0
      dt2 = dt * dt;
      s   = v * dt + a * dt2 / 2. + R * dt2 * dt / 6.;
      *nt = dt;

      // теперь задача сводится к торможению после равномерного движения
      // в две или три фазы
      v = v1 - v; // считаем, что остаточная скорость положительна для удобства

      if (v <= Ad2 / R)
      { // торможение состоит из 3-х фаз
        dt   = sqrt(v / R); // время фазы 2 или 3
        s   -= dt * v;  // тормозной путь ф2 и ф3
        *nt += dt * 2.; // время торможения ф2 и ф3
      }
      else
      { // торможение состоит из 4-х фаз
        dt   = v / self->Ad + self->Ad / R; // время фаз 2, 3 и 4
        s   -= v * dt / 2.; // тормозной путь ф2..ф4
        *nt += dt;          // время торможения ф2..ф4
      }
    }
  }

  return s * sig; // вернуть тормозной путь со знаком
}
//-----------------------------------------------------------------------------
// проверка возможности заданного перемещения за один такт
// (функция возвращает 1, если перемещение на dx возможно за 1 такт, иначе 0)
static int rfilt_jump(
  rfilt_t *self, // указатель на внутреннюю структуру фильтра (константы)
  double v,      // приведенная текущая скорость
  double a,      // приведенное текущее ускорение
  double dx,     // невязка заданной и текущей позиции
  double dt)     // максимальное время на заданное перемещение
{
  int i;
  double s, nt, sig;
  double A2 = a * a, A, V, T2;
  double t, t1, t2, r;
  double R = self->R; // предельно-допустимый рывок

  // вычислить тормозной путь и время торможения
  self->s = s = rfilt_s(self, R, v, a, &self->nt);

  if (self->nt > dt) return 0; // тормозной путь более заданного

  // привести знаки относитльн dx
  sig = (dx >= 0.) ? 1. : -1.;
  s  *= sig;
  v  *= sig;
  a  *= sig;
  dx *= sig; // теперь dx >= 0

  // FIXME: magic
  //if (s > dx * (1. + self->B)) return 0; // тормозной путь больше заданного перемещения
  if (s > dx) return 0; // тормозной путь больше заданного перемещения

#if 1
  if (s == dx) return 1; // тормозной путь совпал с заданным перемещением
#endif

  // выбор рывка "разгона"
  r = R;
  if (a < 0. && 2. * v * r <= A2)
    r = -r; // уход от фазы сброса тормозного ускорения

  t1 = 0.;
  t2 = dt - self->nt;

  // итерационный поиск t1 <= t <= t2
  // такого, что S*(t) >= dx, а t+nt(t) <= dt
  // FIXME: не эффективный алгоритм, требуется оптимизация!
  for (i = 0; i < RFILT_ITER_NUM; i++)
  {
    t = (t2 + t1) * 0.5;

    // вычислить S*(t) - суммарный путь разгона и торможения
    T2 = t * t;
    s = v * t + a * T2 * 0.5 + r * T2 * t / 6.;
    V = v + a * t + r * T2 * 0.5;
    A = a + r * t;
    s += rfilt_s(self, R, V, A, &nt); // S*(t)
    //RFILT_DBG("t=%f T(t)=%f S(t)=%f x+S(t)=%f",
    //          t, t+nt, s, self->x + s);

    if (t + nt <= dt)
    {
      if (s >= dx)
      { // S*(t) >= dx => за данное время перемещение возможно
        RFILT_DBG("bingo i=%i (dx=%f dt=%f t=%f T(t)=%f S(t)=%f x+S(t)=%f)",
                  i + 1, dx, dt, t, t+nt, s, self->x + s);
        return 1;
      }
      t1 = t;
    }
    else
      t2 = t;
  }

  return 0;
}
//-----------------------------------------------------------------------------
// расчёт рывка
static double rfilt_r(
  rfilt_t *self, // указатель на внутреннюю структуру фильтра (константы)
  double v,      // приведенная текущая скорость
  double a,      // приведенное текущее ускорение
  double dx)     // невязка заданной и текущей позиции
{
  double r, r1, r2, s1, s2, v1, v2, a1, a2, nt;
  double R = self->R; // максимальный рывок
  double Rw = R  * (1. - self->B); // максимальный рабочий (заниженный) рывок
  double sig = (dx >= 0.) ? 1. : -1.;

  // привести знаки относительно dx
  v  *= sig;
  a  *= sig;
  dx *= sig; // теперь dx >= 0

#if 1 // FIXME: магия для ликвидации выбега
  dx *= 1. - self->B;
#endif

  // рассчитать тормозной путь для максимального и минимального рывка
  // на следующем такте
  r1 = rfilt_limit_r(self, v, a, -R);
  r2 = rfilt_limit_r(self, v, a,  R);
  s1 = v + a * 0.5 + r1 / 6.;
  s2 = v + a * 0.5 + r2 / 6.;
  v1 = v + a + r1 * 0.5;
  v2 = v + a + r2 * 0.5;
  a1 = a + r1;
  a2 = a + r2;
  s1 += rfilt_s(self, Rw, v1, a1, &nt);
  s2 += rfilt_s(self, Rw, v2, a2, &nt);

  if (dx <= s1 && dx <= s2)
  { // торможение
    double A2 = a * a;
    double Ad2 = self->Ad * self->Ad;
    if (s1 <= s2) r = r1; // dx <= s1 <= s2
    else          r = r2; // dx <= s2 <  s1
    // торможение состоит из от 1-й до 4-х фаз:
    // 1. сброс ускорения разгона с рывком r=-R и набором скорости (если a>0)
    // 2. набор (добор) тормозного ускорения со сбросом скорости и с рывком r=-R
    // 3. сброс скорости с постоянным ускорением без рывка r=0 (если ускорение достигло максимума)
    // 4. сброс скорости и тормозного ускорения до нуля с положительным рывком r=Rw
    if (a > 0.)
    { // фаза 1: требуется сброс ускорения разгона до 0 и далее
      r = -R;
      RFILT_DBG("stop phase #1");
    }
    else // if a <= 0
    {
      if (2. * v * Rw <= A2)
      { // фаза 4: требуется сброс тормозного ускорения и остаточной скорости до нуля
        //r = R;
        //r = Rw;
        r = A2 / (2. * v); // FIXME
        if (r > -a) r = a;
        RFILT_DBG("stop phase #4");
      }
      else if (v <= v + (A2 - Ad2) / (2. * Rw) ||
               a <= -self->Ad)
      { // фаза 3: сброс скорости без рывка до a*a/(2*Rw) c a=-Ad
        r = 0.;
        RFILT_DBG("stop phase #3");
      }
      else // a > -Ad && 2*v*Rd > a2 && a<=0 && v<=v+(a2-Ad2)/(2*Rd)
      { // фаза 2: набор/добор тормозного ускорения до -Ad
        r = -R;
        if (a + r < -self->Ad)
          r = -self->Ad - a;
        RFILT_DBG("stop phase #2");
      }
    }
    r = rfilt_limit_r(self, v, a, r);
  }
  else if (dx >= s1 && dx >= s2)
  { // разгон с +/-R
    if (s1 >= s2) r = r1; // s2 <= s1 <= dx
    else          r = r2; // s1 <  s2 <= dx
    RFILT_DBG("move");
  }
  else
  { // пропорциональное управление рывком (dx между s1 и s2)
    if (s1 == s2)
    { // такого не может быть, но защита от деления на нуль должна быть 
      r = 0.;
    }
    else
    { // найти S(r) ~ dx
      int i;
      double s, k = (r2 - r1) / (s2 - s1);
#if 0
      double s;
      if (s2 < s1)
      { // поменять местами s1 <=> s2, r1 <=> r2
        r  = r1;
        r1 = r2;
        r2 = r;
        s  = s1;
        s1 = s2;
        s2 = s; // теперь s1 <= dx <= s2;
      }

      if (s1 >= 0.)
      { // 0 <= s1 <= dx <= s2
        r = r1; 
      }
      else
        r = 0.; // FIXME
#else
      //  вычисалить начальное значение методом секущей 
      r = (dx - s1) * k + r1;
#endif
      RFILT_DBG("begin r=%f", r * sig);

      // подбор рывка методом простой итерации
      for (i = 0; i < RFILT_ITER_NUM; i++)
      {
        double V = v + a + r * 0.5;
        double A = a + r;
        s = v + a * 0.5 + r / 6.;
        s += rfilt_s(self, Rw, V, A, &nt);
        r += (dx - s) * k;
        if (s <= dx && i >= (RFILT_ITER_NUM/2)) break; // FIXME
        //RFILT_DBG("iterate i=%i r=%f s(r)=%f",
        //           i, r * sig, s * sig);
      }
      RFILT_DBG("latch i=%i r=%f (r1=%f r2=%f s1=%f s2=%f s(r)=%f dx=%f nt(r)=%f)",
                i, r * sig, r1 * sig, r2 * sig, s1 * sig, s2 * sig, s * sig, dx * sig, nt);
    }
  }

  // восстановить знаки
  return r * sig;
}
//-----------------------------------------------------------------------------
// выполнить шаг фильтрации
// (функция возвращает "профильтрованное" значение с учетом ограничений)
double rfilt_step(
  rfilt_t *self, // указатель на внутреннюю структуру фильтра
  double y)      // входное значение для фильтра
{
  double dx, r;

  // ограничить заданное значение
  y = RFILT_LIMIT(y, self->Xmin, self->Xmax);

  // требуемое перемещение
  dx = y - self->x;

#if 1
  // проверить возможность "малого хода"
  if (rfilt_jump(self, self->v, self->a, dx, 1.0))
  {
    RFILT_DBG("pipe mode: x=y=%f v=%f a=%f s=%f, nt=%f",
              y, self->v, self->a, self->s, self->nt);
    self->v = self->a = 0.;
    self->x = y;
    return self->x;
  }
#else
  // вычислить тормозной путь и время торможения
  self->s = rfilt_s(self, self->R, self->v, self->a, &self->nt);
#endif

  // вычислить рывок
  r = rfilt_r(self, self->v, self->a, dx);

  RFILT_DBG("work: y=%f x=%f v=%f a=%f r=%f dx=%f s=%f x+s=%f nt=%f",
             y, self->x, self->v, self->a, r, dx, self->s,
             self->x + self->s, self->nt);

  // выполнить расчёт следующей позиции, скорости и ускорения
  self->x += self->v + self->a * 0.5 + r / 6.;
  self->v += self->a + r * 0.5;
  self->a += r;

  return self->x;
}
//-----------------------------------------------------------------------------

/*** end of "rfilt.c" file ***/

