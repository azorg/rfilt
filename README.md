Нелинейный фильтр ограничения скорости, ускорения и рывка
=========================================================

Фильтр может быть использован при решении различных задачь управления
приводами, кранами, станками с ЧПУ, 3d принтерами,
в железнодорожном и другом транспорте, в радиолокации, в авиации,
при управлении БЛА, в ракето и торпедостроении, при проектировани лифтов,
при построении различными прицензионных систем плавного пуска и торможения.  

При "медленноменяющихся" входных значениях выходная последовательность
повторяет входную (должна!).

Выходные значения "стараются максимально быстро повторять" входные,
но на первую, вторую и третью производную выходного значения накладываются
ограничения.

Для инициализиции и сброса фильтра служит функция rfilt_init().
Для обновления параметров фильтра "на лету" служит функция rfilt_tune().
Основаня рабочая функция фильтра - rfilt_step().

ИДЕЯ ФИЛЬТРА
------------
Считается, что выходное значение на каждом интервале меняется по закону:
```
dt = t[i+1] - t[i]
x[i+1] = x[i] + V[i] * dt + A[i] * dt^2 / 2 + R[i] * dt^3 / 6  (1)
где:
  dt     - шаг разбиения по времени;
  x[i]   - выходное значение на текущем шаге
  x[i+1] - выходное значение на следующем шаге
  V[i]   - текущая (начальная на интервале) скорость
  A[i]   - текущее (начальника на интервале) ускорение
  R[i]   - выбранный для данного интервала рывок
```

Скорость и ускорение расчитывается следующим образом:
```
  V[i+1] = V[i] + A[i] * dt + R[i] * dt^2 / 2                  (2)
  aAi+1] = A[i] + R[i] * dt                                    (3)
```

Для того, чтобы при вычислениях не использовать dt, dt^2 и dt^3 используются
приведенные величины скорости, ускорения и рывка (фактически это конечные
разности первого, второго и третьего порядка):
```
  v[i] = dx[i]  = V[i] * dt
  a[i] = d2x[i] = A[i] * dt^2
  r[i] = d3x[i] = R[i] * dt^3
```
При такой подмене формулы (1), (2) и (3) принимаеют упращенный вид:
```
  x[i+1] = x[i] + v[i] + a[i] / 2 + r[i] / 6   (1')
  v[i+1] = v[i] + a[i] + r[i] / 2              (2')
  a[i+1] = a[i] + r[i]                         (3')
```

Не простой задачей является вычислене оптимального значения величины r[i] для
каждого интервала разбиения.
Оптимизация проводится по минимальному времени достижения заданного значения
на выходе фильтра при движении с заданными ограничениями величин скорости,
ускорения и рывка.

Пользовтаель задает следующие ограничения для работы фильтра:
```
  v_max        - максимальная скорость изменения выходного значения
  a_up_max     - максимальное ускорение разгона
  a_down_max   - максимальное ускорение торможения
  x_min, x_mаx - минимальное и максимальное выходное значение
```
При работе фильтра далее используются следующие обозначения
приведенных значений порогов скорости, ускорения и рывка:
```
  V  = v_max * dt,        V  > 0
  Au = a_up_max   * dt^2, Au > 0
  Ad = a_down_max * dt^2, Ad > 0
  R  = r_max * dt^3,      R  > 0
```

Для текущего зачния скрости и ускорения вычислятся "минимальный тормозной
путь" - величина перемещения при отимальном торможении до нулевой скорости
и нулевого ускорения с ограничением скорости, ускорения и рывка.

Если "пора/нужно томозиить", то выбирается рывок для данной фазы оптимального
торможения.

Понятие разгона и торможения
----------------------------
Если модуль скорости растет то это _разгон_ (v[i] * a[i] > 0),
если модуль скорости снижается, то это _торможение_ (v[i] * a[i] < 0).

Так как при разгоне и торможении используются разные параметры ограничения
ускорения, то может исползоваться следующий код:

```
  trend = v[i] * a[i];
  if (trend < 0.)
  { // торможение (скорость и ускорение не равны нулю и имеют разный знак
    A = Ad; // максимальное приведенное ускорение торможения
  }
  else if (trend > 0. || a[i] != 0.)
  { // разгон (знаки скорости и ускорения совпадают
    // или есть ускорение при нулевой скорости)
    A = Au; // максмальное приведенное ускорение разгона
  }
```

Характерные стратегии управления
--------------------------------

1. Полный покой
Предыдущее выходное значение равно заданному, текущая скорость и ускорение
равны нули. Нулевой рывок сохраняет состояние системы.
Полный покой - это частный случай _малого хода_ и отдельно в
программе не обрабатывается.

2. Малый ход
Текущие малые значения скорости и ускорения, близость заданного значения
к предыдущему позволяют без превышения установленных ограничения по скорости,
ускорения и рывку произвести перемещение за время не более одиного такта dt
и перейти к покою (обнулить V и A).

_Малый ход_ - это работа фильтра в режиме "трубы", когда выходные значения
полностью без задержек и искажений повторяют входные.

Режим _малого хода_ возможен, если величина тормозного пути не превышает
разницу заданного и текущего положения, а время торможения не превышает dt.

После такта _малого хода_ скорость и ускорение обнуляются.

Код проверки возможности _малого хода_:
```
  s = rfilt_s(self, v[i], a[i], &nt, &r);
  // s - тормозной путь, nt - время торможения в тактах
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  if (nt <= 1. &&
      ((ds >= 0. && s <= ds) ||
       (ds <= 0. && s >= ds)))
  { // есть условия для малого хода!
    // r[i] = 0.; // рывок не нужен
    // v[i+1] = a[i+1] = 0.; // обнулить приведенные ускорения и скорость 
    // x[i+1] = y[i]; // вернуть заданное значение
  }
```

3. Торможение
В случае, если кротчайший тормозной путь приводит к выбегу выходного
значения за заданное значение, то активируется программа торможения:
```
  s = rfilt_s(self, v[i], a[i], &nt, &r); // s - тормозной путь со знаком
  // если (x[i]+s) "перепрыгнул" через y[i] => тормозим!
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  if ((ds >= 0. && s >= ds) ||
      (ds <= 0. && s <= ds))
  {
    // ТОРМОЗИМ! Снижаем скорость!
  }
```

4. Реверс
Направление движения (знак скорости) не соответсвует разнице
заданного и текущего положения.
Требуется изменить направление движения.
```
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  dir = ds * v[i];
  if (dir < 0.)
  { // реверс!
    if (ds > 0.)
      r[i] = LIMIT_ABS( Ad - a[i], R); // максимальный рывок в сторону Ad
    else
      r[i] = LIMIT_ABS(-Ad - a[i], R); // максимальный рывок в сторону -Ad
  }





```
На _реверсе_ - требуется достичь максимального ускорения торможения Ad
до тех пор пока "неверная" скорость не достигнет нуля.
 

5. Разгон
Производится набор скорости (с максимально допустимым рывком и ускорением).

Режим _разгона_ возможен, если величина тормозного пути не
превышает разницу заданного и текущего положения, и не требуется снижения
ускоения разгона в связи с близостью достижения максимальной скорости.
```
  Критеческая скорость разгона:
  Vcrit = V - a[i]^2 / (2. * R),
  где
    V - максимально допустимая приведенная скорость (V > 0),
    R - максимально допустимый приведенный рывок (R > 0).
```
Определение возможности свободного разгона без превышения предельной
скорости можно следующим образом
```
  if ((a[i] >=0 && v[i] <  Vcrit) || // скорость растёт и не превысит V
      (a[i] < 0 && v[i] > -Vcrit))   // скорость падает и не снизится ниже -V
  {
    // свободный разгон, возможно увеличение скорости
    
  }
  else
  { // достигнута критическая скорость Vcrit, требуется обнуление ускорения
    r[i] = LIMIT_ABS(-a[i], R);

    
      
  }

```

5. Удержание Vmax
При достижение максимальной скорости v[i] >= V или v[i] <= -V
ускорение должно быть обнулено

Таблица знаков
--------------
| Nреж | ds = y[i]-x[i] |  v  |  a  | Режим             |
|:----:|:--------------:|:---:|:---:|:----------------- |
|  1   |        0       |  0  |  0  | Покой             |
|  2   |        ~0      |  ~0 |  ~0 | Малый ход         |
|  3   |        +       |  +  |  -  | Торможение        |
|  3   |        -       |  -  |  +  | Торможение        |
|  4   |        +       |  -  |  -  | Провал в реверс   |
|  4   |        -       |  +  |  +  | Провал в реверс   |
|  4   |        +       |  -  |  +  | Выход из реверса  |
|  4   |        -       |  +  |  -  | Выход из реверса  |
|  5   |        +       |  +  |  +  | Разгон            |
|  5   |        -       |  -  |  -  | Разгон            |
|  5   |        +       |  +  |  0  | Удердание +Vmax   |
|  5   |        -       |  -  |  0  | Удердание -Vmax   |


Примечание:
  На начальной фазе прогаммного торможения из-за ограничения
  рывка знаки могут соответвовать режму "Разгон", пока ускорение
  не поменят знак на соответсвующий снижению скорости.


