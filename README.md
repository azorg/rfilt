Нелинейный фильтр ограничения скорости, ускорения и рывка
=========================================================

Фильтр может быть использован при решении различных задачь управления
приводами, кранами, станками с ЧПУ, 3d принтерами,
в железнодорожном и другом транспорте, в радиолокации, в авиации,
при управлении БЛА, в ракето и торпедостроении, при проектировани лифтов,
при построении различными прицензионных систем плавного пуска и торможения.  

При "медленноменяющихся" входных значениях выходная последовательность
повторяет входную (должна!).

Выходные значения "стараются максимально быстро повторять" входные,
но на первую, вторую и третью производную выходного значения накладываются
ограничения.

Для инициализиции и сброса фильтра служит функция rfilt_init().
Для обновления параметров фильтра "на лету" служит функция rfilt_tune().
Основаня рабочая функция фильтра - rfilt_step().

ИДЕЯ ФИЛЬТРА
------------
Считается, что выходное значение на каждом интервале меняется по закону:
```
dt = t[i+1] - t[i]
x[i+1] = x[i] + V[i] * dt + A[i] * dt^2 / 2 + R[i] * dt^3 / 6  (1)
где:
  dt     - шаг разбиения по времени;
  x[i]   - выходное значение на текущем шаге
  x[i+1] - выходное значение на следующем шаге
  V[i]   - текущая (начальная на интервале) скорость
  A[i]   - текущее (начальника на интервале) ускорение
  R[i]   - выбранный для данного интервала рывок
```

Скорость и ускорение расчитывается следующим образом:
```
  V[i+1] = V[i] + A[i] * dt + R[i] * dt^2 / 2                  (2)
  aAi+1] = A[i] + R[i] * dt                                    (3)
```

Для того, чтобы при вычислениях не использовать dt, dt^2 и dt^3 используются
приведенные величины скорости, ускорения и рывка (фактически это конечные
разности первого, второго и третьего порядка):
```
  v[i] = dx[i]  = V[i] * dt
  a[i] = d2x[i] = A[i] * dt^2
  r[i] = d3x[i] = R[i] * dt^3
```
При такой подмене формулы (1), (2) и (3) принимаеют упращенный вид:
```
  x[i+1] = x[i] + v[i] + a[i] / 2 + r[i] / 6   (1')
  v[i+1] = v[i] + a[i] + r[i] / 2              (2')
  a[i+1] = a[i] + r[i]                         (3')
```

Не простой задачей является вычислене оптимального значения величины r[i] для
каждого интервала разбиения.
Оптимизация проводится по минимальному времени достижения заданного значения
на выходе фильтра при движении с заданными ограничениями величин скорости,
ускорения и рывка.

Пользовтаель задает следующие ограничения для работы фильтра:
```
  v_max        - максимальная скорость изменения выходного значения
  a_up_max     - максимальное ускорение разгона
  a_down_max   - максимальное ускорение торможения
  x_min, x_mаx - минимальное и максимальное выходное значение
```
При работе фильтра далее используются следующие обозначения
приведенных значений порогов скорости, ускорения и рывка:
```
  V  = v_max * dt,        V  > 0
  Au = a_up_max   * dt^2, Au > 0
  Ad = a_down_max * dt^2, Ad > 0
  R  = r_max * dt^3,      R  > 0
```

Для текущего зачния скрости и ускорения вычислятся "минимальный тормозной
путь" - величина перемещения при отимальном торможении до нулевой скорости
и нулевого ускорения с ограничением скорости, ускорения и рывка.

Если "пора/нужно томозиить", то выбирается рывок для данной фазы оптимального
торможения.

Понятие разгона и торможения
----------------------------
Если модуль скорости растет то это _разгон_ (v[i] * a[i] > 0),
если модуль скорости снижается, то это _торможение_ (v[i] * a[i] < 0).

Так как при разгоне и торможении используются разные параметры ограничения
ускорения, то может исползоваться следующий код:

```
  trend = v[i] * a[i];
  if (trend < 0.)
  { // торможение (скорость и ускорение не равны нулю и имеют разный знак
    A = Ad; // максимальное приведенное ускорение торможения
  }
  else if (trend > 0. || a[i] != 0.)
  { // разгон (знаки скорости и ускорения совпадают
    // или есть ускорение при нулевой скорости)
    A = Au; // максмальное приведенное ускорение разгона
  }
```

Характерные стратегии управления
--------------------------------

1. Полный покой
Предыдущее выходное значение равно заданному, текущая скорость и ускорение
равны нули. Нулевой рывок сохраняет состояние системы.
Полный покой - это частный случай _малого хода_ и отдельно в
программе не обрабатывается.

2. Малый ход
Текущие малые значения скорости и ускорения, близость заданного значения
к предыдущему позволяют без превышения установленных ограничения по скорости,
ускорения и рывку произвести перемещение за время не более одиного такта dt
и перейти к покою (обнулить V и A).

_Малый ход_ - это работа фильтра в режиме "трубы", когда выходные значения
полностью без задержек и искажений повторяют входные.

Режим _малого хода_ возможен, если величина тормозного пути не превышает
разницу заданного и текущего положения, а время торможения не превышает dt.

После такта _малого хода_ скорость и ускорение обнуляются.

Код проверки возможности _малого хода_:
```
  s = rfilt_s(self, v[i], a[i], &nt, &r);
  // s - тормозной путь, nt - время торможения в тактах
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  if (nt <= 1. &&
      ((ds >= 0. && s <= ds) ||
       (ds <= 0. && s >= ds)))
  { // есть условия для малого хода!
    // r[i] = 0.; // рывок не нужен
    // v[i+1] = a[i+1] = 0.; // обнулить приведенные ускорения и скорость 
    // x[i+1] = y[i]; // вернуть заданное значение
  }
```

3. Торможение
В случае, если кротчайший тормозной путь приводит к выбегу выходного
значения за заданное значение, то активируется программа торможения:
```
  s = rfilt_s(self, v[i], a[i], &nt, &r); // s - тормозной путь со знаком
  // если (x[i]+s) "перепрыгнул" через y[i] => тормозим!
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  if ((ds >= 0. && s >= ds) ||
      (ds <= 0. && s <= ds))
  {
    // ТОРМОЗИМ! Снижаем скорость!
  }
```

4. Реверс
Направление движения (знак скорости) не соответсвует разнице
заданного и текущего положения.
Требуется изменить направление движения.
```
  ds = y[i] - x[i]; // y[i] - входное значение, ds - требуемое перемещение
  dir = ds * v[i];
  if (dir < 0.)
  { // реверс!
    if (ds > 0.)
      r[i] = LIMIT_ABS( Ad - a[i], R); // максимальный рывок в сторону Ad
    else
      r[i] = LIMIT_ABS(-Ad - a[i], R); // максимальный рывок в сторону -Ad
  }

........


```
На _реверсе_ - требуется достичь максимального ускорения торможения Ad
до тех пор пока "неверная" скорость не достигнет нуля.
 

5. Разгон
Производится набор скорости (с максимально допустимым рывком и ускорением).

Режим _разгона_ возможен, если величина тормозного пути не
превышает разницу заданного и текущего положения, и не требуется снижения
ускоения разгона в связи с близостью достижения максимальной скорости.
```
  Критеческая скорость разгона:
  Vcrit = V - a[i]^2 / (2. * R),
  где
    V - максимально допустимая приведенная скорость (V > 0),
    R - максимально допустимый приведенный рывок (R > 0).
```
Определение возможности свободного разгона без превышения предельной
скорости можно следующим образом
```
  if ((a[i] >=0 && v[i] <  Vcrit) || // скорость растёт и не превысит V
      (a[i] < 0 && v[i] > -Vcrit))   // скорость падает и не снизится ниже -V
  {
    // свободный разгон, возможно увеличение скорости
    
  }
  else
  { // достигнута критическая скорость Vcrit, требуется обнуление ускорения
    r[i] = LIMIT_ABS(-a[i], R);

    
      
  }

```

5. Удержание Vmax
При достижение максимальной скорости v[i] >= V или v[i] <= -V
ускорение должно быть обнулено

Таблица знаков
--------------
| Nреж | ds = y[i]-x[i] |  v  |  a  | Режим             |
|:----:|:--------------:|:---:|:---:|:----------------- |
|  1   |        0       |  0  |  0  | Покой             |
|  2   |        ~0      |  ~0 |  ~0 | Малый ход         |
|  3   |        +       |  +  |  -  | Торможение        |
|  3   |        -       |  -  |  +  | Торможение        |
|  4   |        +       |  -  |  -  | Провал в реверс   |
|  4   |        -       |  +  |  +  | Провал в реверс   |
|  4   |        +       |  -  |  +  | Выход из реверса  |
|  4   |        -       |  +  |  -  | Выход из реверса  |
|  5   |        +       |  +  |  +  | Разгон            |
|  5   |        -       |  -  |  -  | Разгон            |
|  5   |        +       |  +  |  0  | Удердание +Vmax   |
|  5   |        -       |  -  |  0  | Удердание -Vmax   |


Примечание:
  На начальной фазе прогаммного торможения из-за ограничения
  рывка знаки могут соответвовать режму "Разгон", пока ускорение
  не поменят знак на соответсвующий снижению скорости.


Расчёт траекторий тормозного пути
---------------------------------
При расчете тормозного пути УДОБНО запомнить знак скорости
(фактически направление движения) и если скорость отрицательна
поменять знак скорости и ускорения на противоположный, вычислить
тормозной путь (время тормржения) для положительного значения
начальной скорости (что удобнее, меньше шансов совершить ошибку).
Знак тормозного пути поменять на выходе, если знак скорости
и ускорения меннялся.

Скорость набираемая/сбрасываемая за время снижения ускорения разгона/торможения
до нуля:
```
dV = a^2 / (2 * R),                                            (4)
где
  a - ускорение на начале интервала (начальное ускорение)
  R - рывок с которым ведется линейное снижение до нуля ускорения
```

Еще раз в рамочку, соотношение скорости и ускорения, которые могут обеспечить
торможение с постоянным рывком R до полной остноовки (v = a = 0):
```
2 * V * R = A^2
T = A / R  
```

## Время и тормозной путь после равномерного движения с постоянной скоростью
Если осуществляется движение с постоянной скоростью (ускорение равно нулю),
то торможене может стостоять из 2-х или 3-х фаз.

Если начальная скорость (по модулю) |v| <= Ad^2 / R,
где 
  Ad - максимальное ускорение торможения,
  R - максимальный рывок,
то торможение состоит из 2-х "симметричных" фаз:
- фаза линейного набора ускорения торможения до amax = sqrt(|v| * R),
где
  v - скорость на начале интервала,
  R - максимальный рывок (скорость нарастания ускорения торможения)
- фаза линейного снижения ускорения торможения с amax до нуля.
Время обоих фаз одинаковое.
Из-за сравнительно не большой начальной скорости за время тормозного
пути ускорение торможения не успевает достигуть максимально дорустимого
значения Ad.
Время каждой фазы t1 = t2 = |amax| / R = sqrt(|v| / R)
```
Время полного торможения T2 = t1 + t2 = 2 * sqrt(|v| / R).       (5)
```

Тормозной путь второй фазы можно легко посчитать, если представить
движение в обратном времени с постоянным рывком R от нулевой скорости
и ускорения до скорости |v|/2 и ускорения |amax| в течении t2:
```
s2 = 1/6 * R * t2^3 = 1/6 * |v| * sqrt(|v| / R) = 1/6 * amax^3 / R^2
``` 

Тормозной путь первой фазы можно представить как площадь под графиком
скорости, а это площадь прямоугольника |v| * t1 за вычетом s2, т.е
s1 = |v| * sqrt(|v| / R) - s2,

```
Общий тормозной путь:
S2 = s1 + s2 = |v| * sqrt(|v| / R)                               (6)
```

Если начальная скорость (по модулю) |v| > Ad^2 / R, то торможение
состоит из 3-х фаз:
- фаза линейного набора ускорения торможения до максимального Ad
- фаза равноускоренного торможение с максимальным ускорением Ad
- фаза линейного снижения ускорения торможения с Ad до нуля и сброс скорости

Время первой и третей фазы t1 = t3 = Ad / R.
Время второй фазы можно посчитать как время сброса скорости
с постоянным ускорением ad на величину |v| - 2 * V12 с ускорением Ad,
где V12 = Ad^2 / (2 * R) - величины сброса скорости на 1-й и 3-й фазе,
то есть: t2 = |v| / Ad - Ad / R.
```
Время полного торможения T3 = t1 + t2 + t3 = |v| / Ad + Ad / R    (7)
```

Тормозной путь первой фазы - как площадь под графиком функции скорости:
s1 = |v| * t1 - s3 = |v| * Ad / R - s3

Тормозной путь второй фазы - площад тропеции с основаниемями
v1 = |v| - Ad^2 / (2 * R), v2 = Ad^2 / (2 * R) и высотой t2
s2 = t2 * (v1 + v2) / 2 = (|v| / Ad - Ad / R) * |v| / 2

```
Суммарный тормозной путь всех 3-х фаз
S3 = s1 + s2 + s3 = |v| * (Ad / R + |v| / A) / 2                   (8)
```

## Время и часть тормозного пути сброса ускорения разгона до нуля
При разгоне, когда знаки скорости и ускорения совпадают при использовании
максимального рывка для обнуления ускорения разгона затрачивается
время:
```
Ts = |a| / R,                                                      (9)
где |a| - модуль текущего ускорения разгона, а часть тормозного пути составляет
Ss = |a| / R * (|v| + a^2 / (3 * R))                               (10)

```
После данного интервала (сброса ускорения разгона) расчёт тормозного
пути и времени может быть осуществлен в соответствии с алгоритмом
торможения после равномерного движения с постоянной скорости,
приведенном выше.

## Время и тормозной путь после начала торможения
После начала "настоящего" торможения, когда знаки скорости и ускорения
не совпадают, тормозной путь и время вычисляется особенно хлопотно.

Возможно торможение в 2 фазы:
- увеличение ускорения торможения вплоть до максимального Ad,
- сброс ускорения торможения до нуля и полный останов.
Данные фазы аналогичны 2-м фазам торможения после равномерного
движения с постоянной скоростью с особенностью в том, что
первая фаза "усечена" по времени т.к. мы уже тормозим
и набрали какое-то отрицательное по отношение к скорости ускорение. 

Возможно торможение в 3 фазы:
- увеличение ускорения торможения до максимального Ad,
- торможение с максимальным ускорением Ad,
- сброс ускорения торможения до нуля и полный останов.
Данные фазы аналогичны 3-м фазам торможения после равномерного
движения с постоянной скоростью с особенностью в том, что
первая фаза "усечена" по времени т.к. мы уже тормозим
и набрали какое-то отрицательное по отношение к скорости ускорение. 

Возможна щекотливая ситуация (почему?) с "выбегом" по скорости,
когда за время сбрасывания ускорения с максимальным рывком
скорость успевает поменять знак, что приводит к торможению
в 4-5 фаз с реверсом (изменением знака скорости):
- сброс скорости до нуля, при этом ускорение до нуля не доходит
- сброс ускорения до нуля
- 2 или 3 фазы торможения после движения с постоянной скорось (см. выше).
За счет "выбега" (изменения знака скорости) торможение происходит "долго".

Если модуль скорости меньше, чем v1 = a^2 / (2 * R), то торможение будет с
"выбегом" с большим числом фаз.

Если моуль скорости больше, чем v2 = (Ad^2 - a[i]^2 / 2) / R, то торможение 
в три фазы, в противном случае в две.
Примечание:
```
v2 = dV1 + dV3 - пороговая скорость для 3-х фазного торможения
dV1 = (Ad^2 - a[i]^2) / (2 * R) - падение скорости по модулю за первую фазу
dV3 = Ad^2 / (2 * R) - скорость на входе в третью фазу 
```

Первая фаза из трех (увеличиваем тормозное ускорение с а[i] до Ad):
```
t1 = (Ad - |a[i]|) / R
s1 = v * t1 + a * t1^2 / 2 - R * t1^3 / 6
```

Вторая фаза из трех (тормозим с постоянным ускорением Ad):
```
t2 = (|v| - v2) / Ad;
s2 = (|v| + a^2 / (2 * R)) * t2 / 2
```
Примечаение: s2 - это площадь трапеции с основаниями:
Va = |v| - dV1, Vb = dV3 и высотой h=t2. 
s2 = (Va + Vb) * h / 2

Третья фаза из трех (обнуляем скорость и ускорение с максимальным рывком):
```
t3 = Ad / R;
s3 = R * t3^3 / 6.;
```

T3 = t1 + t2 + t3
S3 = s1 + s2 + s3

Если торможение в две фазы (v <= v2), то вычисляем:
```
Amax = sqrt(R * |v| + a^2 / 2) - максимальное по модулю ускорения
t1 = (Amax - |a|) / R - время первой фазы
t2 = Amax / R         - время второй фазы
s1 = v * t1 + a * t1^2 / 2 - R * t1^3 / 6 - путь первой фазы
s2 = Amax^3 / (6 * R^2)   
T2 = t1 + t2
S2 = s1 + s2

```

Первая фаза из двух (увеличиваем тормозное ускорения с а[i] до Amax):
```
```

Вторая фаза из двух (обнуляем скорость и ускорение с максимальным рывком):
```
t2 = Amax / R;
s2 = R * t2^3 / 6.;
```

T2 = t1 + t2
S2 = s1 + s2


